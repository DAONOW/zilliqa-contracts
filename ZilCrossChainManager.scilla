scilla_version 0

import Polynetwork BoolUtils

library ZilCrossChainManager

let nullAddress = 0x0000000000000000000000000000000000000000

type Error =
  | ContractFrozenFailure
  | ConPubKeysAlreadyInitialized
  | ErrorDeserializeHeader
  | NextBookersIllegal
  | SignatureVerificationFailed
  | HeaderLowerOrBookKeeperEmpty

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | ContractFrozenFailure => Int32 -1
      | ConPubKeysAlreadyInitialized => Int32 -2
      | ErrorDeserializeHeader => Int32 -3
      | NextBookersIllegal => Int32 -4
      | SignatureVerificationFailed => Int32 -5
      | HeaderLowerOrBookKeeperEmpty => Int32 -6
      end
    in
    { _exception: "Error"; code: result_code }
(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract ZilCrossChainManager
()


field paused: Bool = True

(* When Poly chain switches the consensus epoch book keepers, *)
(* the consensus peers public keys of Poly chain should be    *)
(* changed into no-compressed version so that solidity smart  *)
(* contract can convert it to address type and verify the     *)
(* signature derived from Poly chain account signature.       *)
(* conKeepersPublicKeyList means Consensus book Keepers       *)
(* Public Key List                                            *)
field conKeepersPublicKeyList: List ByStr20 = Nil {ByStr20}

(* Current Epoch Start Height of Poly chain block *)
field curEpochStartHeight: Uint32 = Uint32 0

procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure IsNotPaused()
  paused_tmp <- paused;
  match paused_tmp with
  | False =>
  | True  =>
    e = ContractFrozenFailure;
    ThrowError e
  end
end

procedure verifyPubkeysAndUpdate(pubkeys: List Pubkey, h_nextBookkeeper: ByStr20, h_height: Uint32)
      nextbookkeeper_keepers = verifyPubkey pubkeys;
      match nextbookkeeper_keepers with
      | Pair nextBookKeeper keepers =>
        (* Ensure that Header's nextBookKeeper is same as the one from verifyPubkey *)
        nbk_eq = builtin eq nextBookKeeper h_nextBookkeeper;
        match nbk_eq with
        | True =>
          curEpochStartHeight := h_height;
          conKeepersPublicKeyList := keepers
        | False =>
          e = NextBookersIllegal;
          ThrowError e
        end
      end

end

(* @dev: sync Poly chain genesis block header to smart contrat. *)
(* @param rawHeader: Poly chain genesis block raw header or raw *)
(* Header including switching consensus peers info              *)
(* @param pubkeys:  Poly chain consensus nodes public key list. *)
(* todo who can invoke this function                            *)
transition InitGenesisBlock(rawHeader: ByStr, pubkeys: List Pubkey)
  IsNotPaused;
  current_keepers_o <- conKeepersPublicKeyList;
  match current_keepers_o with
  | Nil =>
    header_o = deserialize_Header rawHeader zero_uint32;
    match header_o with
    | Some
      (Pair
        (Header h_version h_chainid h_prevBlockHash h_txnroot h_crossStatesRoot
                h_blockRoot h_timestamp h_height h_consensusData h_consensusPayload
                h_nextBookkeeper)
        nextpos)
      =>
        verifyPubkeysAndUpdate pubkeys h_nextBookkeeper h_height;
        e = { _eventname : "GenesisBlock"; height : h_height; header : rawHeader };
        event e
    | None =>
      e = ErrorDeserializeHeader;
      ThrowError e
    end
  | Cons _ _ =>
    e = ConPubKeysAlreadyInitialized;
    ThrowError e
  end
end

(* @dev: sync Poly chain genesis block header to smart contrat. *)
(* @param rawHeader: Poly chain genesis block raw header or raw *)
(* Header including switching consensus peers info.             *)
(* @param pubkeys:  Poly chain consensus nodes public key list. *)
(* @param sigList:  Poly chain consensus nodes signature list.  *)
(* todo who can invoke this function                            *)
transition ChangeBookKeeper(rawHeader: ByStr, pubkeys: List Pubkey, sigList: List Signature)
  IsNotPaused;
  header_o = deserialize_Header rawHeader zero_uint32;
  curStartHeight <- curEpochStartHeight;
  match header_o with
  | Some
      (Pair
        (Header h_version h_chainid h_prevBlockHash h_txnroot h_crossStatesRoot
                h_blockRoot h_timestamp h_height h_consensusData h_consensusPayload
                h_nextBookkeeper)
        nextpos)
    =>
      heightOk = builtin lt curStartHeight h_height;
      nextBookKeeperOk = let b = builtin eq h_nextBookkeeper nullAddress in negb b;
      both_ok = andb heightOk nextBookKeeperOk;
      match both_ok with
      | True =>
        curKeepers <- conKeepersPublicKeyList;
        n = lengther_address curKeepers;
        m = compute_m n;
        signed = verifySig rawHeader sigList curKeepers m;
        match signed with
        | True =>
          verifyPubkeysAndUpdate pubkeys h_nextBookkeeper h_height;
          e = { _eventname : "ChangeBookKeeper"; height : h_height; header : rawHeader };
          event e
        | False =>
          e = SignatureVerificationFailed;
          ThrowError e
        end
      | False =>
        e = HeaderLowerOrBookKeeperEmpty;
        ThrowError e
      end
   | None =>
     e = ErrorDeserializeHeader;
     ThrowError e
  end
end