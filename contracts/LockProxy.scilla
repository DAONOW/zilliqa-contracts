scilla_version 0

library LockProxy

type TxArgs = 
| TxArgs of ByStr ByStr Uint256

type Error = 
  | AdminValidationFailed
  | AmountCannotBeZero
  | LockAmountMismatch
  | IllegalToAssetHash
  | IllegalToAmount

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | AdminValidationFailed => Int32 -1
      | AmountCannotBeZero => Int32 -2
      | LockAmountMismatch => Int32 -3
      | IllegalToAssetHash => Int32 -4
      | IllegalToAmount => Int32 -5
      end
    in
    { _exception: "Error"; code: result_code }


let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
      Cons {Message} m e

let uint128_zero = Uint128 0
let zero_address = 0x0000000000000000000000000000000000000000

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract LockProxy(
  init_admin: ByStr20,
  init_manager_proxy: ByStr20
)

field contractadmin: ByStr20  = init_admin
field asset_map: Map ByStr20 (Map Uint64 ByStr) = Emp ByStr20 (Map Uint64 ByStr)

(* Procedures *)
procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure IsAdmin(initiator: ByStr20)
  contractadmin_tmp <- contractadmin;
  is_admin = builtin eq initiator contractadmin_tmp;
  match is_admin with
  | True  =>
  | False =>
    e = AdminValidationFailed;
    ThrowError e
  end
end

(* lock amount should not be zero *)
procedure ValidateAmount(amount: Uint128)
  is_zero = builtin eq amount uint128_zero;
  match is_zero with
  | True =>
    e =  AmountCannotBeZero;
    ThrowError e
  | False =>
  end
end

(* @param fromAssetHash: The asset address in current chain, uniformly named as `fromAssetHash` *)
(* @param fromAddress: obtained by _sender *)
(* @param toAddress: address is this contract: _this_address *)
(* @param amount:   The amount of tokens to be crossed from ethereum to the chain with chainId  *)
procedure transferZRC2ToContract(fromAssetHash: ByStr20, fromAddress: ByStr20, toAddress: ByStr20, amount: Uint128)
  msg_to_zrc2 = {_tag: "TransferFrom"; _recipient: fromAssetHash; _amount: uint128_zero; 
  from: fromAddress; to: toAddress; amount: amount};
  msgs = one_msg msg_to_zrc2;
  send msgs
end

(* transfer asset from fromAddress to LockProxy contract *)
procedure TransferToContract(fromAssetHash: ByStr20, amount: Uint128)
  (* if people choose to lock native zil, then fromAssetHash should be 0x0000000000000000000000000000000000000000 *)
  is_asset_zil = builtin eq fromAssetHash zero_address;
  match is_asset_zil with
  | True =>
    accept;
    is_amount_correct = builtin eq _amount amount;
    match is_amount_correct with
    | True =>
      e = { _eventname: "TransferToContract"; fromAssetHash: fromAssetHash; amount: amount };
      event e
    | False =>
      e = LockAmountMismatch;
      ThrowError e
    end
  | False =>
    (* no accept here, so even some zils is transfered, there is no harm *)
    (* see IncreaseAllowance in ZRC2 *)
    transferZRC2ToContract fromAssetHash _sender _this_address amount;
    e = { _eventname: "TransferToContract"; fromAssetHash: fromAssetHash; amount: amount };
    event e
  end
end

(* This function is meant to be invoked by the user *)
(* a certin amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.*)
(* Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later. *)
(* @param fromAssetHash: The asset address in current chain, uniformly named as `fromAssetHash` *)
(* @param toChainId:  The target chain id *)
(* @param toAddress:  The address in bytes format to receive same amount of tokens in target chain  *)
(* @param amount:   The amount of tokens to be crossed from ethereum to the chain with chainId  *)
transition Lock(fromAssetHash: ByStr20, toChainId: Uint64, toAddress: ByStr, amount: Uint128)
  ValidateAmount amount;
  TransferToContract fromAssetHash amount;
  toAssetHash_o <- asset_map[fromAssetHash][toChainId];
  match toAssetHash_o with
  | Some toAssetHash =>
    amount_256_o = builtin to_uint256 amount;
    match amount_256_o with
    | Some amount_256 =>
      txArgs = TxArgs toAssetHash toAddress amount_256;
      e = { _eventname: "Lock" };
      event e
    | None =>
      e = IllegalToAmount;
      ThrowError e
    end
  | None =>
    e = IllegalToAssetHash;
    ThrowError e
  end
end

transition BindAssetHash(fromAssetHash: ByStr20, toChainId: Uint64, toAssetHash: ByStr)
  IsAdmin _sender;
  asset_map[fromAssetHash][toChainId] := toAssetHash;
  e = { _eventname: "BindAssetHash" };
  event e
end


